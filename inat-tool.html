<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iNaturalist Metadata Tool</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.45; }
    h1 { text-align: center; margin-bottom: 0.25rem; }
    .muted { color: #555; font-size: 0.95rem; }
    textarea { width: 100%; height: 150px; margin: 0.75rem 0 1rem; }
    .controls { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.5rem; }
    button { padding: 0.6rem 1rem; font-size: 1rem; cursor: pointer; }
    label { user-select: none; }
    #status { margin-top: 1rem; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .downloads { display: flex; gap: 0.5rem; margin-top: 0.25rem; }
  </style>
  <!-- XLSX (SheetJS) for Excel export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>iNaturalist Metadata Tool</h1>
  <p class="muted">
    <b>How it works:</b> Paste one iNaturalist observation ID per line (you can also paste full observation URLs).
    Click <b>Fetch Data</b>. The tool calls the iNaturalist API in your browser, maps fields to your specimen schema,
    and lets you download a <b>CSV</b> or <b>Excel (.xlsx)</b> file. Optional: toggle <b>Reverse Geocoding</b> to fill
    County/Municipality/Locality (slower; rateâ€‘limited). When geocoding is off, it still parses common US formats
    like <i>"Alachua County, FL, USA"</i> to populate <b>County</b> and <b>stateprovince</b>.
  </p>
  <p class="muted">
    <b>Habitat & Substrate (optional):</b> To populate these columns, add Observation Fields on each iNat observation named
    exactly <code>Habitat</code> and <code>Fungus Substrate/Host</code>. The tool reads those field values automatically.
    (Collector field number is read from <code>Collector Field Number</code> if present.)
  </p>

  <textarea id="idInput" placeholder="123456789\nhttps://www.inaturalist.org/observations/654321\n... one per line"></textarea>

  <div class="controls">
    <button id="runBtn">Fetch Data</button>
    <label><input type="checkbox" id="geoToggle"> Try reverse geocoding (slower)</label>
  </div>

  <div class="downloads">
    <button id="csvBtn" disabled>Download CSV</button>
    <button id="xlsxBtn" disabled>Download XLSX</button>
  </div>

  <div id="status"></div>

  <script>
    const FIELDNAMES = [
      'catalognumber', 'scientificName', 'Uploaded to Mycoportal (date)',
      'AssociatedSequences', 'Label Printed', 'identificationqualifier',
      'OtherCatalogNumbers', 'recordNumber', 'typeStatus', 'recordedBy',
      'identifiedBY', 'verbatimeventdate', 'year', 'month', 'day',
      'Country', 'stateprovince', 'County', 'Locality', 'Municipality',
      'Habitat', 'Substrate', 'Host', 'decimalLatitude', 'decimalLongitude',
      'VerbatimLatitude', 'VerbatimLongitude', 'georeferencedby',
      'occurrenceremarks', 'Elevation', 'LifeStage', 'AssociatedMedia',
      'GeocodedLocality'
    ];

    let gRows = [];

    document.getElementById('runBtn').addEventListener('click', fetchData);
    document.getElementById('csvBtn').addEventListener('click', () => downloadCSV(gRows));
    document.getElementById('xlsxBtn').addEventListener('click', () => downloadXLSX(gRows));

    function parseIdsFromText(text) {
      return text
        .split(/\n+/)
        .map(line => line.trim())
        .filter(Boolean)
        .map(line => {
          // Accept raw IDs or full URLs; pick the last numeric token
          const m = line.match(/(\d{3,})/g);
          return m ? m[m.length - 1] : '';
        })
        .filter(Boolean);
    }

    async function fetchData() {
      const ids = parseIdsFromText(document.getElementById('idInput').value);
      if (ids.length === 0) { alert('Please enter at least one observation ID.'); return; }

      const doGeocode = document.getElementById('geoToggle').checked;
      const status = document.getElementById('status');
      status.textContent = `Fetching ${ids.length} observation(s)...`;

      const rows = [];
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        try {
          const obs = await fetchObservation(id);
          if (!obs) {
            rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}` }));
          } else {
            const row = await buildRowFromObservation(obs, doGeocode);
            rows.push(row);
          }
          status.textContent = `Fetched ${i + 1}/${ids.length}`;
          if (i < ids.length - 1) await sleep(500);
        } catch (e) {
          rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}`, occurrenceremarks: `Error: ${e.message}` }));
        }
      }

      gRows = rows; // store for downloads
      document.getElementById('csvBtn').disabled = rows.length === 0;
      document.getElementById('xlsxBtn').disabled = rows.length === 0;
      status.textContent += '\nReady to download.';
    }

    async function fetchObservation(id) {
      const url = `https://api.inaturalist.org/v1/observations/${encodeURIComponent(id)}`;
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      if (!res.ok) return null;
      const data = await res.json();
      return (data && data.results && data.results[0]) ? data.results[0] : null;
    }

    function findObservationFieldValue(ofvs, name) {
      if (!Array.isArray(ofvs)) return '';
      const lower = String(name).toLowerCase();
      for (const ofv of ofvs) {
        const n = (ofv && ofv.observation_field && ofv.observation_field.name) ? ofv.observation_field.name.toLowerCase() : '';
        if (n === lower) return ofv.value || '';
      }
      return '';
    }

    function parsePlaceGuessFallback(place_guess) {
      // Heuristics for common US pattern like: "Gainesville, Alachua County, FL, USA" or "Alachua County, FL, USA"
      const out = { country: '', state: '', county: '', municipality: '' };
      if (!place_guess) return out;
      const parts = place_guess.split(',').map(p => p.trim()).filter(Boolean);
      if (parts.length === 0) return out;

      // Country detection
      const countryIdx = parts.findIndex(p => /^(USA|United States|United States of America)$/i.test(p));
      if (countryIdx !== -1) out.country = 'USA';

      // State is usually the part before the country token, if present
      if (countryIdx > 0) {
        out.state = parts[countryIdx - 1] || '';
      }

      // County/Parish/Borough: pick the first part that contains those words
      const countyPart = parts.find(p => /(County|Parish|Borough)$/i.test(p));
      if (countyPart) out.county = countyPart;

      // Municipality (optional): pick a city/town/village-looking first token that is not county/state/country
      const excluded = new Set([out.state, out.county, 'USA', 'United States', 'United States of America']);
      const muniCandidate = parts.find(p => !excluded.has(p) && !/^(\w{2})$/.test(p)); // skip 2-letter states
      if (muniCandidate) out.municipality = muniCandidate;

      return out;
    }

    async function buildRowFromObservation(obs, doGeocode) {
      const id = obs.id || '';
      const taxon = obs.taxon || {};
      const user = obs.user || {};
      const ofvs = obs.ofvs || [];

      const observed_on = obs.observed_on || obs.created_at || '';
      let year = '', month = '', day = '';
      if (/^\d{4}-\d{2}-\d{2}/.test(observed_on)) {
        const [y, m, d] = observed_on.split('T')[0].split('-');
        year = y || ''; month = Number(m || '') || ''; day = Number(d || '') || '';
      }

      let latitude = '', longitude = '';
      if (obs.location && typeof obs.location === 'string' && obs.location.includes(',')) {
        const parts = obs.location.split(',');
        latitude = (parts[0] || '').trim();
        longitude = (parts[1] || '').trim();
      }

      const place_guess = obs.place_guess || '';

      // Fallback parsing from place_guess to fill US-style County/State when geocoding is off
      const pgFallback = parsePlaceGuessFallback(place_guess);

      // Start with fallback values; optionally override with reverse geocoding
      let geoCountry = pgFallback.country || '';
      let geoState = pgFallback.state || '';
      let geoCounty = pgFallback.county || '';
      let geoMunicipality = pgFallback.municipality || '';
      let geocodedLocality = '';

      // Optional reverse geocoding (overrides when available)
      if (doGeocode && latitude && longitude) {
        try {
          const geo = await reverseGeocodeNominatim(latitude, longitude);
          if (geo) {
            if (geo.country) geoCountry = geo.country;
            if (geo.state) geoState = geo.state;
            if (geo.county) geoCounty = geo.county;
            if (geo.municipality) geoMunicipality = geo.municipality;
            if (geo.locality) geocodedLocality = geo.locality;
          }
          await sleep(1100); // be polite to Nominatim
        } catch (_) {}
      }

      const habitat = findObservationFieldValue(ofvs, 'Habitat');
      const substrate = findObservationFieldValue(ofvs, 'Fungus Substrate/Host');
      const collector_number = findObservationFieldValue(ofvs, 'Collector Field Number');

      return rowWithDefaults({
        scientificName: taxon.name || '',
        'Uploaded to Mycoportal (date)': '',
        AssociatedSequences: '',
        'Label Printed': '',
        identificationqualifier: '',
        OtherCatalogNumbers: id ? `iNaturalist #${id}` : '',
        recordNumber: collector_number,
        typeStatus: '',
        recordedBy: user.name || user.login || '',
        identifiedBY: user.name || user.login || '',
        verbatimeventdate: observed_on,
        year: year,
        month: month,
        day: day,
        Country: geoCountry || (place_guess.includes('USA') || place_guess.includes('United States') ? 'USA' : ''),
        stateprovince: geoState,
        County: geoCounty,
        Locality: place_guess,
        Municipality: geoMunicipality,
        Habitat: habitat,
        Substrate: substrate,
        Host: '',
        decimalLatitude: latitude,
        decimalLongitude: longitude,
        VerbatimLatitude: '',
        VerbatimLongitude: '',
        georeferencedby: '',
        occurrenceremarks: obs.description || '',
        Elevation: '',
        LifeStage: '',
        AssociatedMedia: id ? `https://www.inaturalist.org/observations/${id}` : '',
        GeocodedLocality: geocodedLocality
      });
    }

    async function reverseGeocodeNominatim(lat, lon) {
      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('lat', String(lat));
      url.searchParams.set('lon', String(lon));
      url.searchParams.set('format', 'json');
      url.searchParams.set('addressdetails', '1');
      url.searchParams.set('zoom', '16');
      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
      if (!res.ok) return null;
      const data = await res.json();
      const addr = data.address || {};
      return {
        country: addr.country || '',
        state: addr.state || '',
        county: addr.county || '',
        municipality: addr.city || addr.town || addr.village || addr.municipality || addr.suburb || addr.hamlet || '',
        locality: addr.leisure || addr.tourism || addr.natural || addr.landuse || addr.amenity || addr.place || addr.suburb || addr.neighbourhood || addr.hamlet || addr.road || ''
      };
    }

    function downloadCSV(rows) {
      if (!rows || rows.length === 0) return;
      const headers = FIELDNAMES;
      const csvLines = [headers.join(',')];
      for (const r of rows) {
        const line = headers.map(h => csvEscape(r[h] ?? '')).join(',');
        csvLines.push(line);
      }
      const blob = new Blob([csvLines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'inat_specimens.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadXLSX(rows) {
      if (!rows || rows.length === 0 || typeof XLSX === 'undefined') return;
      // Ensure consistent column order
      const normalized = rows.map(r => {
        const o = {}; FIELDNAMES.forEach(k => o[k] = r[k] ?? ''); return o;
      });
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.json_to_sheet(normalized, { header: FIELDNAMES });
      XLSX.utils.book_append_sheet(wb, ws, 'Specimens');
      XLSX.writeFile(wb, 'inat_specimens.xlsx');
    }

    function csvEscape(value) {
      const s = String(value).replace(/"/g, '""');
      return '"' + s + '"';
    }

    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  </script>
</body>
</html>
