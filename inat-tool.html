<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iNaturalist Metadata Tool</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; line-height: 1.45; }
    h1 { text-align: center; margin-bottom: 0.25rem; }
    .muted { color: #555; font-size: 0.95rem; }
    textarea { width: 100%; height: 150px; margin: 0.75rem 0 1rem; }
    .controls { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.5rem; }
    button { padding: 0.6rem 1rem; font-size: 1rem; cursor: pointer; }
    label { user-select: none; }
    #status { margin-top: 1rem; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    .downloads { display: flex; gap: 0.5rem; margin-top: 0.25rem; }
  </style>
  <!-- XLSX (SheetJS) for Excel export -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
  <h1>iNaturalist Metadata Tool</h1>
  <p class="muted">
    <b>How it works:</b> Paste one iNaturalist observation ID per line (you can also paste full observation URLs).
    Click <b>Fetch Data</b>. The tool calls the iNaturalist API in your browser, maps fields to your specimen schema,
    and lets you download a <b>CSV</b> or <b>Excel (.xlsx)</b> file. Optional: toggle <b>Reverse Geocoding</b> to fill
    County/Municipality/Locality (slower; rateâ€‘limited).
  </p>
  <p class="muted">
    <b>Habitat & Substrate (optional):</b> To populate these columns, add Observation Fields on each iNat observation named
    exactly <code>Habitat</code> and <code>Fungus Substrate/Host</code>. The tool reads those field values automatically.
    (Collector field number is read from <code>Collector Field Number</code> if present.)
  </p>
  <p class="muted">
    <b>Output format:</b> The CSV/Excel files will match your FLAS specimen format exactly, with the iNaturalist observation
    link automatically formatted for the VerbatimAttributes column as a clickable HTML link.
  </p>

  <textarea id="idInput" placeholder="123456789&#10;https://www.inaturalist.org/observations/654321&#10;... one per line"></textarea>

  <div class="controls">
    <button id="runBtn">Fetch Data</button>
    <label><input type="checkbox" id="geoToggle"> Try reverse geocoding (slower)</label>
  </div>

  <div class="downloads">
    <button id="csvBtn" disabled>Download CSV</button>
    <button id="xlsxBtn" disabled>Download XLSX</button>
  </div>

  <div id="status"></div>

  <script>
    const FIELDNAMES = [
      'catalognumber', 'scientificName', 'Uploaded to Mycoportal (date)',
      'AssociatedSequences', 'Label Printed', 'identificationqualifier',
      'OtherCatalogNumbers', 'recordNumber', 'typeStatus', 'recordedBy',
      'identifiedBY', 'verbatimeventdate', 'year', 'month', 'day',
      'Country', 'stateprovince', 'County', 'Locality', 'Municipality',
      'Habitat', 'Substrate', 'Host', 'decimalLatitude', 'decimalLongitude',
      'VerbatimLatitude', 'VerbatimLongitude', 'georeferencedby',
      'occurrenceremarks', 'Elevation', 'LifeStage', 'AssociatedMedia',
      'GeocodedLocality'
    ];

    let gRows = [];

    document.getElementById('runBtn').addEventListener('click', fetchData);
    document.getElementById('csvBtn').addEventListener('click', () => downloadCSV(gRows));
    document.getElementById('xlsxBtn').addEventListener('click', () => downloadXLSX(gRows));

    function parseIdsFromText(text) {
      return text
        .split(/\n+/)
        .map(line => line.trim())
        .filter(Boolean)
        .map(line => {
          // Accept raw IDs or full URLs; pick the last numeric token
          const m = line.match(/(\d{3,})/g);
          return m ? m[m.length - 1] : '';
        })
        .filter(Boolean);
    }

    async function fetchData() {
      const ids = parseIdsFromText(document.getElementById('idInput').value);
      if (ids.length === 0) { alert('Please enter at least one observation ID.'); return; }

      const doGeocode = document.getElementById('geoToggle').checked;
      const status = document.getElementById('status');
      status.textContent = `Fetching ${ids.length} observation(s)...`;

      const rows = [];
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        try {
          const obs = await fetchObservation(id);
          if (!obs) {
            rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}` }));
          } else {
            const row = await buildRowFromObservation(obs, doGeocode);
            rows.push(row);
          }
          status.textContent = `Fetched ${i + 1}/${ids.length}`;
          if (i < ids.length - 1) await sleep(500);
        } catch (e) {
          rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}`, occurrenceremarks: `Error: ${e.message}` }));
        }
      }

      gRows = rows; // store for downloads
      document.getElementById('csvBtn').disabled = rows.length === 0;
      document.getElementById('xlsxBtn').disabled = rows.length === 0;
      status.textContent += '\nReady to download.';
    }

    async function fetchObservation(id) {
      const url = `https://api.inaturalist.org/v1/observations/${encodeURIComponent(id)}`;
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      if (!res.ok) return null;
      const data = await res.json();
      return (data && data.results && data.results[0]) ? data.results[0] : null;
    }

    function findObservationFieldValue(ofvs, name) {
      if (!Array.isArray(ofvs)) return '';
      const lower = String(name).toLowerCase();
      for (const ofv of ofvs) {
        const n = (ofv && ofv.observation_field && ofv.observation_field.name) ? ofv.observation_field.name.toLowerCase() : '';
        if (n === lower) return ofv.value || '';
      }
      return '';
    }

    async function buildRowFromObservation(obs, doGeocode) {
      const id = obs.id || '';
      const taxon = obs.taxon || {};
      const user = obs.user || {};
      const ofvs = obs.ofvs || [];

      const observed_on = obs.observed_on || obs.created_at || '';
      let year = '', month = '', day = '';
      if (/^\d{4}-\d{2}-\d{2}/.test(observed_on)) {
        const [y, m, d] = observed_on.split('T')[0].split('-');
        year = y || ''; month = Number(m || '') || ''; day = Number(d || '') || '';
      }

      let latitude = '', longitude = '';
      if (obs.location && typeof obs.location === 'string' && obs.location.includes(',')) {
        const parts = obs.location.split(',');
        latitude = (parts[0] || '').trim();
        longitude = (parts[1] || '').trim();
      }

      const place_guess = obs.place_guess || '';

      // Initialize geocoding variables with default values
      let geoCountry = 'USA';
      let geoState = '';
      let geoCounty = '';
      let geoMunicipality = '';
      let geocodedLocality = '';

      // Try to extract basic location info from iNaturalist place_guess if available
      if (place_guess && !doGeocode) {
        // Simple parsing of place_guess to extract state/county if possible
        const parts = place_guess.split(',').map(p => p.trim());
        if (parts.length >= 2) {
          // Last part is often country, second to last is often state
          if (parts[parts.length - 1].toLowerCase().includes('us') || parts[parts.length - 1].toLowerCase() === 'united states') {
            geoCountry = 'USA';
            if (parts.length >= 2) {
              geoState = parts[parts.length - 2];
            }
            if (parts.length >= 3) {
              geoCounty = parts[parts.length - 3];
            }
          }
        }
      }

      // Optional reverse geocoding (overrides basic parsing)
      if (doGeocode && latitude && longitude) {
        try {
          const geo = await reverseGeocodeNominatim(latitude, longitude);
          if (geo) {
            geoCountry = geo.country || geoCountry;
            geoState = geo.state || geoState;
            geoCounty = geo.county || geoCounty;
            geoMunicipality = geo.municipality || geoMunicipality;
            geocodedLocality = geo.locality || geocodedLocality;
          }
          await sleep(1100); // be polite to Nominatim
        } catch (e) {
          console.warn('Geocoding failed:', e);
        }
      }

      const habitat = findObservationFieldValue(ofvs, 'Habitat');
      const substrate = findObservationFieldValue(ofvs, 'Fungus Substrate/Host');
      const collector_number = findObservationFieldValue(ofvs, 'Collector Field Number');

      const row = rowWithDefaults({
        scientificName: taxon.name || '',
        'Uploaded to Mycoportal (date)': '',
        AssociatedSequences: '',
        'Label Printed': '',
        identificationqualifier: '',
        OtherCatalogNumbers: id ? `iNaturalist #${id}` : '',
        recordNumber: collector_number,
        typeStatus: '',
        recordedBy: user.name || user.login || '',
        identifiedBY: user.name || user.login || '',
        verbatimeventdate: observed_on,
        year: year,
        month: month,
        day: day,
        Country: geoCountry,
        stateprovince: geoState,
        County: geoCounty,
        Locality: place_guess,
        Municipality: geoMunicipality,
        Habitat: habitat,
        Substrate: substrate,
        Host: '',
        decimalLatitude: latitude,
        decimalLongitude: longitude,
        VerbatimLatitude: '',
        VerbatimLongitude: '',
        georeferencedby: '',
        occurrenceremarks: obs.description || '',
        Elevation: '',
        LifeStage: '',
        AssociatedMedia: id ? `https://www.inaturalist.org/observations/${id}` : '',
        GeocodedLocality: geocodedLocality
      });

      // Debug logging to verify the data is being set
      console.log(`Observation ${id}: State="${geoState}", County="${geoCounty}"`);
      
      return row;
    }

    function rowWithDefaults(overrides = {}) {
      const row = {};
      for (const key of FIELDNAMES) row[key] = '';
      Object.assign(row, overrides);
      return row;
    }

    async function reverseGeocodeNominatim(lat, lon) {
      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('lat', String(lat));
      url.searchParams.set('lon', String(lon));
      url.searchParams.set('format', 'json');
      url.searchParams.set('addressdetails', '1');
      url.searchParams.set('zoom', '16');
      const res = await fetch(url.toString(), { headers: { 'Accept': 'application/json' } });
      if (!res.ok) throw new Error(`Geocoding failed: ${res.status}`);
      const data = await res.json();
      const addr = data.address || {};
      
      // More comprehensive state extraction
      const state = addr.state || addr.province || addr.region || '';
      // More comprehensive county extraction
      const county = addr.county || addr.administrative_area_level_2 || '';
      
      return {
        country: addr.country || '',
        state: state,
        county: county,
        municipality: addr.city || addr.town || addr.village || addr.municipality || addr.suburb || addr.hamlet || '',
        locality: addr.leisure || addr.tourism || addr.natural || addr.landuse || addr.amenity || addr.place || addr.suburb || addr.neighbourhood || addr.hamlet || addr.road || ''
      };
    }

    function downloadCSV(rows) {
      if (!rows || rows.length === 0) return;
      const headers = FIELDNAMES;
      const csvLines = [headers.join(',')];
      for (const r of rows) {
        const line = headers.map(h => csvEscape(r[h] ?? '')).join(',');
        csvLines.push(line);
      }
      const blob = new Blob([csvLines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'inat_specimens.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function downloadXLSX(rows) {
      if (!rows || rows.length === 0 || typeof XLSX === 'undefined') return;
      
      // Ensure consistent column order
      const normalized = rows.map(r => {
        const o = {}; FIELDNAMES.forEach(k => o[k] = r[k] ?? ''); return o;
      });
      
      // Create array with two header rows + data
      const allData = [
        FIELDNAMES,
        FIELD_DESCRIPTIONS,
        ...normalized.map(row => FIELDNAMES.map(field => row[field]))
      ];
      
      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(allData);
      XLSX.utils.book_append_sheet(wb, ws, 'Specimens');
      XLSX.writeFile(wb, 'inat_specimens.xlsx');
    }

    function csvEscape(value) {
      const s = String(value).replace(/"/g, '""');
      return '"' + s + '"';
    }

    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  </script>
</body>
</html>
