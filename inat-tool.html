<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>iNaturalist Metadata Tool</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2rem; }
    h1 { text-align: center; }
    textarea { width: 100%; height: 150px; margin-bottom: 1rem; }
    .controls { display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; }
    button { padding: 0.6rem 1rem; font-size: 1rem; cursor: pointer; }
    label { user-select: none; }
    #status { margin-top: 1rem; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  </style>
</head>
<body>
  <h1>iNaturalist Metadata Tool</h1>
  <p>Paste iNaturalist observation IDs (one per line). Click <b>Fetch Data</b> to generate a CSV matching your specimen fields.</p>

  <textarea id="idInput" placeholder="123456789\n987654321\n... one ID per line"></textarea>

  <div class="controls">
    <button id="runBtn">Fetch Data</button>
    <label><input type="checkbox" id="geoToggle"> Try reverse geocoding (slower)</label>
  </div>

  <div id="status"></div>

  <script>
    const FIELDNAMES = [
      'catalognumber', 'scientificName', 'Uploaded to Mycoportal (date)',
      'AssociatedSequences', 'Label Printed', 'identificationqualifier',
      'OtherCatalogNumbers', 'recordNumber', 'typeStatus', 'recordedBy',
      'identifiedBY', 'verbatimeventdate', 'year', 'month', 'day',
      'Country', 'stateprovince', 'County', 'Locality', 'Municipality',
      'Habitat', 'Substrate', 'Host', 'decimalLatitude', 'decimalLongitude',
      'VerbatimLatitude', 'VerbatimLongitude', 'georeferencedby',
      'occurrenceremarks', 'Elevation', 'LifeStage', 'AssociatedMedia',
      'GeocodedLocality'
    ];

    document.getElementById('runBtn').addEventListener('click', fetchData);

    async function fetchData() {
      const ids = document.getElementById('idInput').value
        .split(/\s+/)
        .map(s => s.trim())
        .filter(Boolean);

      if (ids.length === 0) { alert('Please enter at least one observation ID.'); return; }

      const doGeocode = document.getElementById('geoToggle').checked;
      const status = document.getElementById('status');
      status.textContent = `Fetching ${ids.length} observation(s)...`;

      const rows = [];
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i];
        try {
          const obs = await fetchObservation(id);
          if (!obs) {
            rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}` }));
          } else {
            const row = await buildRowFromObservation(obs, doGeocode);
            rows.push(row);
          }
          status.textContent = `Fetched ${i + 1}/${ids.length}`;
          // Gentle pacing to be polite to APIs
          if (i < ids.length - 1) await sleep(500);
        } catch (e) {
          rows.push(rowWithDefaults({ OtherCatalogNumbers: `iNaturalist #${id}`, AssociatedMedia: `https://www.inaturalist.org/observations/${id}`, occurrenceremarks: `Error: ${e.message}` }));
        }
      }

      downloadCSV(rows);
      status.textContent += '\nCSV ready.';
    }

    async function fetchObservation(id) {
      const url = `https://api.inaturalist.org/v1/observations/${encodeURIComponent(id)}`;
      const res = await fetch(url, { headers: { 'Accept': 'application/json' } });
      if (!res.ok) return null;
      const data = await res.json();
      return (data && data.results && data.results[0]) ? data.results[0] : null;
    }

    function findObservationFieldValue(ofvs, name) {
      if (!Array.isArray(ofvs)) return '';
      const lower = String(name).toLowerCase();
      for (const ofv of ofvs) {
        const n = (ofv && ofv.observation_field && ofv.observation_field.name) ? ofv.observation_field.name.toLowerCase() : '';
        if (n === lower) return ofv.value || '';
      }
      return '';
    }

    async function buildRowFromObservation(obs, doGeocode) {
      const id = obs.id || '';
      const taxon = obs.taxon || {};
      const user = obs.user || {};
      const ofvs = obs.ofvs || [];

      const observed_on = obs.observed_on || obs.created_at || '';
      let year = '', month = '', day = '';
      if (/^\d{4}-\d{2}-\d{2}/.test(observed_on)) {
        const [y, m, d] = observed_on.split('T')[0].split('-');
        year = y || ''; month = Number(m || '') || ''; day = Number(d || '') || '';
      }

      let latitude = '', longitude = '';
      if (obs.location && typeof obs.location === 'string' && obs.location.includes(',')) {
        const parts = obs.location.split(',');
        latitude = (parts[0] || '').trim();
        longitude = (parts[1] || '').trim();
      }

      const place_guess = obs.place_guess || '';

      // Optional, courteous reverse geocoding via Nominatim (slow, best-effort)
      let geoCountry = 'USA';
      let geoState = '';
      let geoCounty = '';
      let geoMunicipality = '';
      let geocodedLocality = '';
      if (doGeocode && latitude && longitude) {
        try {
          const geo = await reverseGeocodeNominatim(latitude, longitude);
          if (geo) {
            geoCountry = geo.country || geoCountry;
            geoState = geo.state || '';
            geoCounty = geo.county || '';
            geoMunicipality = geo.municipality || '';
            geocodedLocality = geo.locality || '';
          }
          // Respect Nominatim rate limits
          await sleep(1100);
        } catch (_) {}
      }

      const habitat = findObservationFieldValue(ofvs, 'Habitat');
      const substrate = findObservationFieldValue(ofvs, 'Fungus Substrate/Host');
      const collector_number = findObservationFieldValue(ofvs, 'Collector Field Number');

      const row = rowWithDefaults({
        scientificName: taxon.name || '',
        'Uploaded to Mycoportal (date)': '',
        AssociatedSequences: '',
        'Label Printed': '',
        identificationqualifier: '',
        OtherCatalogNumbers: id ? `iNaturalist #${id}` : '',
        recordNumber: collector_number,
        typeStatus: '',
        recordedBy: user.name || user.login || '',
        identifiedBY: user.name || user.login || '',
        verbatimeventdate: observed_on,
        year: year,
        month: month,
        day: day,
        Country: geoCountry,
        stateprovince: geoState,
        County: geoCounty,
        Locality: place_guess,
        Municipality: geoMunicipality,
        Habitat: habitat,
        Substrate: substrate,
        Host: '',
        decimalLatitude: latitude,
        decimalLongitude: longitude,
        VerbatimLatitude: '',
        VerbatimLongitude: '',
        georeferencedby: '',
        occurrenceremarks: obs.description || '',
        Elevation: '',
        LifeStage: '',
        AssociatedMedia: id ? `https://www.inaturalist.org/observations/${id}` : '',
        GeocodedLocality: geocodedLocality
      });

      return row;
    }

    function rowWithDefaults(overrides = {}) {
      const row = {};
      for (const key of FIELDNAMES) row[key] = '';
      Object.assign(row, overrides);
      return row;
    }

    async function reverseGeocodeNominatim(lat, lon) {
      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('lat', String(lat));
      url.searchParams.set('lon', String(lon));
      url.searchParams.set('format', 'json');
      url.searchParams.set('addressdetails', '1');
      url.searchParams.set('zoom', '16');
      const res = await fetch(url.toString(), {
        headers: { 'Accept': 'application/json', 'User-Agent': 'inat-metadata-tool/1.0 (+github pages)' }
      });
      if (!res.ok) return null;
      const data = await res.json();
      const addr = data.address || {};
      return {
        country: addr.country || '',
        state: addr.state || '',
        county: addr.county || '',
        municipality: addr.city || addr.town || addr.village || addr.municipality || addr.suburb || addr.hamlet || '',
        locality: addr.leisure || addr.tourism || addr.natural || addr.landuse || addr.amenity || addr.place || addr.suburb || addr.neighbourhood || addr.hamlet || addr.road || ''
      };
    }

    function downloadCSV(rows) {
      if (!rows || rows.length === 0) return;
      const headers = FIELDNAMES;
      const csvLines = [headers.join(',')];
      for (const r of rows) {
        const line = headers.map(h => csvEscape(r[h] ?? '')).join(',');
        csvLines.push(line);
      }
      const blob = new Blob([csvLines.join('\n')], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'inat_specimens.csv';
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function csvEscape(value) {
      const s = String(value).replace(/"/g, '""');
      return '"' + s + '"';
    }

    function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }
  </script>
</body>
</html>
