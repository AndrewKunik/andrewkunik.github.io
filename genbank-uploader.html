<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GenBank Source Modifier Generator v2</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 900px;
      margin: 2rem auto;
      padding: 0 1rem;
      line-height: 1.6;
    }
    h1 {
      color: #2c3e50;
      text-align: center;
      margin-bottom: 0.5rem;
    }
    .subtitle {
      text-align: center;
      color: #7f8c8d;
      margin-bottom: 2rem;
    }
    .section {
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }
    .section h2 {
      margin-top: 0;
      color: #495057;
      font-size: 1.2rem;
    }
    .file-input-group {
      margin-bottom: 1rem;
    }
    label {
      display: block;
      font-weight: bold;
      margin-bottom: 0.5rem;
      color: #495057;
    }
    input[type="file"] {
      display: block;
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #ced4da;
      border-radius: 4px;
      background: white;
    }
    .checkbox-group {
      margin: 1rem 0;
    }
    .checkbox-group label {
      display: inline;
      font-weight: normal;
      margin-left: 0.5rem;
    }
    button {
      background: #28a745;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      font-size: 1rem;
      border-radius: 4px;
      cursor: pointer;
      width: 100%;
      font-weight: bold;
    }
    button:hover {
      background: #218838;
    }
    button:disabled {
      background: #6c757d;
      cursor: not-allowed;
    }
    #status {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 4px;
      white-space: pre-wrap;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
    }
    .info {
      background: #d1ecf1;
      border-left: 4px solid #17a2b8;
      padding: 1rem;
      margin-bottom: 1rem;
      border-radius: 4px;
    }
    .error {
      background: #f8d7da;
      border-left: 4px solid #dc3545;
      color: #721c24;
    }
    .success {
      background: #d4edda;
      border-left: 4px solid #28a745;
      color: #155724;
    }
    .warning {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      color: #856404;
    }
    .match-log {
      font-size: 0.85rem;
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h1>GenBank Source Modifier Generator v2</h1>
  <p class="subtitle">Convert FLAS metadata + FASTA to GenBank format</p>

  <div class="info">
    <strong>How it works:</strong>
    <ol>
      <li>Upload your FLAS metadata spreadsheet (CSV or Excel)</li>
      <li>Upload your FASTA file containing sequences</li>
      <li>Tool matches sequences to metadata using:
        <ul>
          <li>FLAS numbers (e.g., FLAS-F-73131)</li>
          <li>iNaturalist numbers from <code>OtherCatalogNumbers</code></li>
          <li>Personal collection numbers from <code>recordNumber</code> (e.g., T22, KUNIK191)</li>
        </ul>
      </li>
      <li>Download tab-delimited GenBank source modifier file</li>
    </ol>
  </div>

  <div class="section">
    <h2>Step 1: Upload FLAS Metadata</h2>
    <div class="file-input-group">
      <label for="metadataFile">FLAS Metadata Spreadsheet (CSV or XLSX):</label>
      <input type="file" id="metadataFile" accept=".csv,.xlsx,.xls,.tsv,.txt">
    </div>
  </div>

  <div class="section">
    <h2>Step 2: Upload FASTA File</h2>
    <div class="file-input-group">
      <label for="fastaFile">FASTA File (.fasta, .fa, .fna, .txt):</label>
      <input type="file" id="fastaFile" accept=".fasta,.fa,.fna,.txt">
    </div>
    <div class="checkbox-group">
      <input type="checkbox" id="useAllSpecimens">
      <label for="useAllSpecimens">Use all specimens from metadata (ignore FASTA matching)</label>
    </div>
  </div>

  <div class="section">
    <h2>Step 3: Generate GenBank File</h2>
    <button id="generateBtn" disabled>Generate GenBank Source Modifier File</button>
    <div id="status"></div>
  </div>

  <script>
    let metadataData = null;
    let fastaData = null;

    const metadataInput = document.getElementById('metadataFile');
    const fastaInput = document.getElementById('fastaFile');
    const generateBtn = document.getElementById('generateBtn');
    const statusDiv = document.getElementById('status');
    const useAllCheckbox = document.getElementById('useAllSpecimens');

    metadataInput.addEventListener('change', handleMetadataUpload);
    fastaInput.addEventListener('change', handleFastaUpload);
    generateBtn.addEventListener('click', generateGenBankFile);

    function updateButtonState() {
      const fastaRequired = !useAllCheckbox.checked;
      generateBtn.disabled = !metadataData || (fastaRequired && !fastaData);
    }

    useAllCheckbox.addEventListener('change', updateButtonState);

    async function handleMetadataUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      statusDiv.textContent = 'Loading metadata...';
      statusDiv.className = '';

      try {
        const fileExtension = file.name.split('.').pop().toLowerCase();
        
        if (fileExtension === 'csv') {
          const text = await file.text();
          const parsed = Papa.parse(text, { header: true, skipEmptyLines: true });
          metadataData = parsed.data;
        } else if (fileExtension === 'tsv' || fileExtension === 'txt') {
          const text = await file.text();
          const parsed = Papa.parse(text, { header: true, skipEmptyLines: true, delimiter: '\t' });
          metadataData = parsed.data;
        } else if (['xlsx', 'xls'].includes(fileExtension)) {
          const arrayBuffer = await file.arrayBuffer();
          const workbook = XLSX.read(arrayBuffer, { type: 'array' });
          const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
          metadataData = XLSX.utils.sheet_to_json(firstSheet);
        }

        // Log column names for debugging
        if (metadataData && metadataData.length > 0) {
          console.log('Metadata columns:', Object.keys(metadataData[0]));
        }

        statusDiv.textContent = `✓ Loaded ${metadataData.length} specimens from metadata`;
        statusDiv.className = 'success';
        updateButtonState();
      } catch (error) {
        statusDiv.textContent = `Error loading metadata: ${error.message}`;
        statusDiv.className = 'error';
        metadataData = null;
        updateButtonState();
      }
    }

    async function handleFastaUpload(e) {
      const file = e.target.files[0];
      if (!file) return;

      statusDiv.textContent = 'Loading FASTA file...';
      statusDiv.className = '';

      try {
        const text = await file.text();
        fastaData = parseFasta(text);
        statusDiv.textContent = `✓ Loaded ${fastaData.length} sequences from FASTA`;
        statusDiv.className = 'success';
        updateButtonState();
      } catch (error) {
        statusDiv.textContent = `Error loading FASTA: ${error.message}`;
        statusDiv.className = 'error';
        fastaData = null;
        updateButtonState();
      }
    }

    function parseFasta(text) {
      const sequences = [];
      const lines = text.split('\n');
      let currentHeader = null;
      let currentSeq = '';

      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('>')) {
          if (currentHeader) {
            sequences.push({ header: currentHeader, sequence: currentSeq });
          }
          currentHeader = trimmed.substring(1);
          currentSeq = '';
        } else if (trimmed) {
          currentSeq += trimmed;
        }
      }

      if (currentHeader) {
        sequences.push({ header: currentHeader, sequence: currentSeq });
      }

      return sequences;
    }

    function extractIdentifiers(header) {
      // Returns an object with all possible identifiers found in the header
      const identifiers = {
        flas: null,
        inat: null,
        recordNum: null,
        allNumbers: [],
        allAlphaNum: [],
        lastPart: null,  // For ONT-style headers where ID is after last hyphen
        primaryId: null, // The main identifier we think this is
        raw: header.trim()
      };

      // FIRST: Check for FLAS number anywhere in the header (highest priority)
      const flasPatterns = [
        /FLAS[_\-]?F[_\-]?\d+/i,
        /FLAS[_\-]?\d+/i
      ];
      for (const pattern of flasPatterns) {
        const match = header.match(pattern);
        if (match) {
          identifiers.flas = match[0].toUpperCase().replace(/_/g, '-');
          identifiers.primaryId = identifiers.flas;
          break;
        }
      }

      // Check for ONT-style header format: ONT##.##-[well]-[identifier]
      // e.g., "ONT01.17-A03-KUNIK512" -> extract "KUNIK512"
      // e.g., "ONT01.17-A03-FLAS-F-73131" -> extract "FLAS-F-73131"
      const ontMatch = header.match(/^ONT\d+\.\d+-[A-H]\d+-(.+)$/i);
      if (ontMatch) {
        identifiers.lastPart = ontMatch[1].trim();
        
        // If lastPart contains a FLAS number, extract it properly
        if (!identifiers.flas && /FLAS/i.test(identifiers.lastPart)) {
          for (const pattern of flasPatterns) {
            const flasMatch = identifiers.lastPart.match(pattern);
            if (flasMatch) {
              identifiers.flas = flasMatch[0].toUpperCase().replace(/_/g, '-');
              identifiers.primaryId = identifiers.flas;
              break;
            }
          }
        }
        
        // If no FLAS found, use lastPart as primaryId
        if (!identifiers.primaryId) {
          identifiers.primaryId = identifiers.lastPart;
        }
      } else if (!identifiers.primaryId) {
        // SIMPLE FORMAT: The identifier is the whole header (or first part before space/underscore)
        // e.g., ">KUNIK512" or ">246162333" or ">KUNIK512_something"
        const simpleMatch = header.match(/^([A-Za-z0-9\.\-]+)/);
        if (simpleMatch) {
          identifiers.primaryId = simpleMatch[1].trim();
          identifiers.lastPart = identifiers.primaryId;
        }
      }

      // Check if primaryId is a pure number (7+ digits = likely iNat)
      if (identifiers.primaryId && /^\d{7,10}$/.test(identifiers.primaryId)) {
        identifiers.inat = identifiers.primaryId;
        identifiers.allNumbers.push(identifiers.primaryId);
      }
      
      // Also extract any other long numbers from the header
      const numberMatches = header.match(/\b(\d{7,10})\b/g);
      if (numberMatches) {
        for (const num of numberMatches) {
          if (!identifiers.allNumbers.includes(num)) {
            identifiers.allNumbers.push(num);
          }
        }
        if (!identifiers.inat) {
          identifiers.inat = numberMatches[0];
        }
      }

      // Check if primaryId looks like a record number (alphanumeric like KUNIK512, T22, JC1)
      // But not if it's a FLAS number
      if (identifiers.primaryId && !identifiers.flas) {
        if (/^[A-Za-z]+\d+/i.test(identifiers.primaryId)) {
          identifiers.recordNum = identifiers.primaryId.toUpperCase();
        }
        // Also handle lowercase codes like "t2", "t22" 
        if (/^[A-Za-z]\d+$/i.test(identifiers.primaryId)) {
          identifiers.recordNum = identifiers.primaryId.toUpperCase();
        }
      }

      // Extract all alphanumeric codes from header as backup
      const alphaNumMatches = header.match(/\b([A-Z]+\d+[\.\dA-Z]*|\d+[A-Z]+[A-Z0-9]*)\b/gi);
      if (alphaNumMatches) {
        identifiers.allAlphaNum = alphaNumMatches
          .filter(m => !m.match(/^FLAS/i) && !m.match(/^ONT/i) && !m.match(/^[A-H]\d+$/i))
          .map(m => m.toUpperCase());
      }
      
      // If we still don't have a recordNum, use first alphanumeric match
      if (!identifiers.recordNum && identifiers.allAlphaNum.length > 0) {
        identifiers.recordNum = identifiers.allAlphaNum[0];
      }

      return identifiers;
    }

    function findMetadataMatch(identifiers) {
      if (!metadataData) return null;

      for (const row of metadataData) {
        // 1. Try matching by FLAS number (catalognumber)
        if (identifiers.flas) {
          const catalogNum = String(row['catalognumber'] || '').toUpperCase().replace(/[_\-\s]/g, '');
          const flasNorm = identifiers.flas.replace(/[_\-\s]/g, '');
          if (catalogNum && catalogNum === flasNorm) {
            return { row, matchedBy: 'FLAS', matchedValue: identifiers.flas };
          }
        }

        // 2. Try matching by iNaturalist number (OtherCatalogNumbers) - EXACT match
        let otherCatNums = String(row['OtherCatalogNumbers'] || '').trim();
        // Handle Excel storing numbers as floats (e.g., "135124662.0" -> "135124662")
        if (otherCatNums.endsWith('.0')) {
          otherCatNums = otherCatNums.slice(0, -2);
        }
        // Also try converting to integer if it's a number
        if (row['OtherCatalogNumbers'] && typeof row['OtherCatalogNumbers'] === 'number') {
          otherCatNums = String(Math.floor(row['OtherCatalogNumbers']));
        }
        
        // Check primaryId first if it's a long number
        if (identifiers.primaryId && /^\d{7,10}$/.test(identifiers.primaryId)) {
          if (otherCatNums === identifiers.primaryId) {
            return { row, matchedBy: 'iNaturalist', matchedValue: identifiers.primaryId };
          }
        }
        
        // Check identified iNat number - EXACT match
        if (identifiers.inat && otherCatNums) {
          if (otherCatNums === identifiers.inat) {
            return { row, matchedBy: 'iNaturalist', matchedValue: identifiers.inat };
          }
        }
        
        // Check all numbers found in header - EXACT match
        for (const num of identifiers.allNumbers) {
          if (otherCatNums === num) {
            return { row, matchedBy: 'iNaturalist', matchedValue: num };
          }
        }

        // 3. Try matching by recordNumber (personal collection number) - EXACT match only!
        const recordNum = String(row['recordNumber'] || '').toUpperCase().trim();
        if (recordNum) {
          // Try primaryId first - EXACT match
          if (identifiers.primaryId) {
            const primaryUpper = identifiers.primaryId.toUpperCase();
            // Exact match only
            if (recordNum === primaryUpper) {
              return { row, matchedBy: 'recordNumber', matchedValue: identifiers.primaryId };
            }
            // Handle cases like KUNIK605.1 in FASTA matching KUNIK605 in metadata
            // But ONLY if the base is an exact match (not partial)
            const primaryBase = primaryUpper.split('.')[0];
            const recordBase = recordNum.split('.')[0];
            if (primaryBase === recordBase && primaryUpper !== primaryBase) {
              // FASTA has suffix like .1, metadata doesn't - OK to match
              return { row, matchedBy: 'recordNumber', matchedValue: identifiers.primaryId };
            }
            if (recordNum !== recordBase && primaryUpper === recordBase) {
              // Metadata has suffix, FASTA doesn't - OK to match
              return { row, matchedBy: 'recordNumber', matchedValue: identifiers.primaryId };
            }
          }
          
          // Try lastPart - EXACT match only
          if (identifiers.lastPart) {
            const lastPartUpper = identifiers.lastPart.toUpperCase();
            if (recordNum === lastPartUpper) {
              return { row, matchedBy: 'recordNumber', matchedValue: identifiers.lastPart };
            }
            // Handle suffix matching (e.g., KUNIK605.1 vs KUNIK605)
            const lastPartBase = lastPartUpper.split('.')[0];
            const recordBase = recordNum.split('.')[0];
            if (lastPartBase === recordBase && (lastPartUpper !== lastPartBase || recordNum !== recordBase)) {
              return { row, matchedBy: 'recordNumber', matchedValue: identifiers.lastPart };
            }
          }
          
          // Check extracted recordNum - EXACT match only
          if (identifiers.recordNum && recordNum === identifiers.recordNum) {
            return { row, matchedBy: 'recordNumber', matchedValue: identifiers.recordNum };
          }
        }
      }

      return null;
    }

    function formatDate(dateStr) {
      if (!dateStr || dateStr === 'undefined' || dateStr === 'null') return '';
      
      // Convert to string and trim
      let dateVal = dateStr;
      
      // Check if it's an Excel serial date number (number between ~1 and ~60000)
      // Excel serial dates: 1 = Jan 1, 1900, 44819 = Sept 15, 2022
      if (typeof dateVal === 'number' || /^\d+$/.test(String(dateVal).trim())) {
        const serialNum = Number(dateVal);
        if (serialNum > 1 && serialNum < 100000) {
          // Convert Excel serial date to JavaScript Date
          // Excel's epoch is Dec 30, 1899 (accounting for the 1900 leap year bug)
          const excelEpoch = new Date(1899, 11, 30);
          const jsDate = new Date(excelEpoch.getTime() + serialNum * 24 * 60 * 60 * 1000);
          
          const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                          'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
          const day = String(jsDate.getDate()).padStart(2, '0');
          const month = months[jsDate.getMonth()];
          const year = jsDate.getFullYear();
          
          return `${day}-${month}-${year}`;
        }
      }
      
      dateStr = String(dateVal).trim();
      if (!dateStr || dateStr === 'NaN' || dateStr === 'undefined-undefined-undefined') return '';
      
      // If it's already in a good format like "15-Jun-2023", return as-is
      if (/^\d{1,2}-[A-Za-z]{3}-\d{4}$/.test(dateStr)) {
        return dateStr;
      }
      
      // Try to parse various date formats
      const date = new Date(dateStr);
      
      // Check if date is valid and not the Unix epoch (which indicates parsing failure)
      if (isNaN(date.getTime()) || date.getFullYear() < 1900 || date.getFullYear() > 2100) {
        // Return original string if it looks like a date, otherwise empty
        if (/\d{4}/.test(dateStr)) {
          return dateStr; // Has a year, return as-is
        }
        return '';
      }

      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 
                      'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const day = String(date.getDate()).padStart(2, '0');
      const month = months[date.getMonth()];
      const year = date.getFullYear();

      return `${day}-${month}-${year}`;
    }

    function formatAltitude(elevation) {
      if (!elevation) return '';
      const num = String(elevation).replace(/[^\d.\-]/g, '');
      return num ? `${num} m` : '';
    }

    function formatGeoLocation(country, state, county) {
      if (!country) country = 'USA';
      const parts = [country];
      if (state) parts.push(state);
      if (county) parts.push(county);
      
      if (parts.length === 1) return country;
      return `${parts[0]}: ${parts.slice(1).join(', ')}`;
    }

    function formatLatLon(lat, lon) {
      if (!lat || !lon) return '';
      return `${lat} ${lon}`;
    }

    function generateGenBankFile() {
      statusDiv.textContent = 'Generating GenBank file...';
      statusDiv.className = '';

      try {
        const useAll = useAllCheckbox.checked;
        let records = [];
        let matchLog = [];

        if (useAll) {
          // Use all specimens from metadata
          records = metadataData.map((row, index) => {
            const seqId = row['catalognumber'] || row['OtherCatalogNumbers'] || `Specimen_${index + 1}`;
            return createGenBankRecord(seqId, row, row['catalognumber']);
          });
          matchLog.push(`Using all ${records.length} specimens from metadata`);
        } else {
          // Match FASTA sequences to metadata
          const matched = [];
          const unmatched = [];

          for (const seq of fastaData) {
            const identifiers = extractIdentifiers(seq.header);
            const match = findMetadataMatch(identifiers);
            
            if (match) {
              // Use the EXACT FASTA header as Sequence_ID
              const flasNum = match.row['catalognumber'] || '';
              records.push(createGenBankRecord(seq.header, match.row, flasNum));
              matched.push({
                header: seq.header,
                matchedBy: match.matchedBy,
                matchedValue: match.matchedValue,
                flas: flasNum
              });
            } else {
              // Include unmatched sequences with blank metadata
              records.push(createGenBankRecord(seq.header, {}, null));
              unmatched.push(seq.header);
            }
          }

          // Build detailed match log
          matchLog.push(`=== MATCHING SUMMARY ===`);
          matchLog.push(`Total sequences: ${fastaData.length}`);
          matchLog.push(`Matched: ${matched.length}`);
          matchLog.push(`Unmatched: ${unmatched.length}`);
          matchLog.push(``);
          
          if (matched.length > 0) {
            matchLog.push(`--- Matched sequences ---`);
            const byMethod = { FLAS: 0, iNaturalist: 0, recordNumber: 0 };
            matched.forEach(m => {
              byMethod[m.matchedBy]++;
            });
            matchLog.push(`  By FLAS number: ${byMethod.FLAS}`);
            matchLog.push(`  By iNaturalist number: ${byMethod.iNaturalist}`);
            matchLog.push(`  By record number: ${byMethod.recordNumber}`);
            matchLog.push(``);
          }

          if (unmatched.length > 0) {
            matchLog.push(`--- Unmatched sequences ---`);
            unmatched.forEach(h => matchLog.push(`  ${h}`));
          }
        }

        if (records.length === 0) {
          statusDiv.textContent = 'Error: No records generated. Check that identifiers in FASTA match metadata.\n\n' + matchLog.join('\n');
          statusDiv.className = 'error';
          return;
        }

        // Generate TSV file
        const headers = ['Sequence_ID', 'Organism', 'collection-date', 'geo_loc_name', 
                        'specimen-voucher', 'altitude', 'collected-by', 'host', 
                        'isolation-source', 'latitude-longitude', 'note'];
        
        const rows = [headers.join('\t')];
        for (const record of records) {
          const row = headers.map(h => record[h] || '').join('\t');
          rows.push(row);
        }

        const tsvContent = rows.join('\n');
        downloadFile(tsvContent, 'genbank_source_modifiers.txt');

        statusDiv.innerHTML = `<div class="match-log">✓ Success! Generated ${records.length} records.\nFile downloaded as genbank_source_modifiers.txt\n\n${matchLog.join('\n')}</div>`;
        statusDiv.className = 'success';

      } catch (error) {
        statusDiv.textContent = `Error: ${error.message}\n${error.stack}`;
        statusDiv.className = 'error';
      }
    }

    function createGenBankRecord(sequenceId, metadata, flasNumber) {
      // Use FLAS number for specimen-voucher
      let specimenVoucher = flasNumber || '';
      
      // If no FLAS number, try to extract from catalog fields
      if (!specimenVoucher) {
        specimenVoucher = metadata['catalognumber'] || '';
      }

      // Build notes: combine iNaturalist link and occurrence remarks
      let notes = [];
      
      // Check for iNaturalist info in VerbatimAttributes (contains the HTML link)
      if (metadata['VerbatimAttributes'] && metadata['VerbatimAttributes'].includes('iNaturalist')) {
        // Extract just the observation number
        const inatMatch = metadata['VerbatimAttributes'].match(/observation[s]?\s*[#]?\s*(\d+)/i);
        if (inatMatch) {
          notes.push(`iNaturalist observation ${inatMatch[1]}`);
        }
      }
      
      // Also check OtherCatalogNumbers for iNat number
      if (metadata['OtherCatalogNumbers']) {
        const inatNum = metadata['OtherCatalogNumbers'];
        if (/^\d+$/.test(inatNum)) {
          notes.push(`iNaturalist observation ${inatNum}`);
        }
      }

      if (metadata['occurrenceremarks']) {
        notes.push(metadata['occurrenceremarks']);
      }

      // Build the collection date - only if we have valid data
      let collectionDate = '';
      if (metadata['verbatimeventdate']) {
        collectionDate = formatDate(metadata['verbatimeventdate']);
      } else if (metadata['year'] && metadata['month'] && metadata['day']) {
        // Only build date string if all parts are present and valid
        const year = metadata['year'];
        const month = metadata['month'];
        const day = metadata['day'];
        if (year && month && day && year !== '' && month !== '' && day !== '') {
          collectionDate = formatDate(`${year}-${month}-${day}`);
        }
      } else if (metadata['year']) {
        // If we only have year, just use that
        collectionDate = String(metadata['year']);
      }

      const record = {
        'Sequence_ID': sequenceId,
        'Organism': (metadata['scientificName'] || '').trim(),
        'collection-date': collectionDate,
        'geo_loc_name': formatGeoLocation(metadata['Country'], metadata['stateprovince'], metadata['County']),
        'specimen-voucher': specimenVoucher,
        'altitude': formatAltitude(metadata['Elevation']),
        'collected-by': metadata['recordedBy'] || '',
        'host': metadata['Host'] || '',
        'isolation-source': metadata['Substrate'] || metadata['Habitat'] || '',
        'latitude-longitude': formatLatLon(metadata['decimalLatitude'], metadata['decimalLongitude']),
        'note': [...new Set(notes)].join('; ')  // Remove duplicates
      };

      return record;
    }

    function downloadFile(content, filename) {
      const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
