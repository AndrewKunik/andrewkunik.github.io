<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GenBank Metadata Extractor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid #f0f0f0;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            color: #666;
            font-size: 1.1em;
        }

        .workflow-section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .workflow-section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.5em;
            display: flex;
            align-items: center;
        }

        .step-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: bold;
        }

        .file-drop-zone {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s ease;
            background: rgba(102, 126, 234, 0.05);
        }

        .file-drop-zone:hover {
            border-color: #5a67d8;
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .file-drop-zone.dragover {
            border-color: #5a67d8;
            background: rgba(102, 126, 234, 0.15);
            transform: scale(1.02);
        }

        .file-input {
            display: none;
        }

        .file-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            margin: 10px;
        }

        .file-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .accession-list {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
        }

        .copy-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.3s ease;
        }

        .copy-button:hover {
            background: #218838;
        }

        .process-button {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            margin: 20px 0;
            transition: all 0.3s ease;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .process-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(40, 167, 69, 0.3);
        }

        .process-button:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .file-list {
            margin: 15px 0;
        }

        .file-item {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            display: flex;
            justify-content: between;
            align-items: center;
        }

        .download-button {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s ease;
        }

        .download-button:hover {
            background: #0056b3;
        }

        .instructions {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .instructions h3 {
            color: #004085;
            margin-bottom: 15px;
        }

        .instructions ol {
            color: #004085;
            padding-left: 20px;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>GenBank Metadata Extractor</h1>
            <p>Extract and organize metadata from FASTA sequences using GenBank records</p>
        </div>

        <!-- Step 1: Upload FASTA file -->
        <div class="workflow-section">
            <h2><span class="step-number">1</span>Upload FASTA File</h2>
            <div class="file-drop-zone" id="fastaDropZone">
                <p>Drag and drop your FASTA file here, or click to browse</p>
                <button class="file-button" onclick="document.getElementById('fastaInput').click()">Choose FASTA File</button>
                <input type="file" id="fastaInput" class="file-input" accept=".fasta,.fa,.fas,.txt" />
            </div>
            <div id="fastaStatus"></div>
        </div>

        <!-- Step 2: Extract GenBank accessions -->
        <div class="workflow-section" id="step2" style="display: none;">
            <h2><span class="step-number">2</span>GenBank Accessions Found</h2>
            <p>Copy this list and paste it into the GenBank search box:</p>
            <div class="instructions">
                <h3>Instructions:</h3>
                <ol>
                    <li>Copy the accession numbers below</li>
                    <li>Go to <a href="https://www.ncbi.nlm.nih.gov/nuccore" target="_blank">NCBI GenBank</a></li>
                    <li>Paste the numbers into the search box</li>
                    <li>Click "Search"</li>
                    <li>Click "Send to" → "Complete Record" → "File" → "GenBank (full)" format</li>
                    <li>Save the .gb file and upload it in Step 3 below</li>
                </ol>
            </div>
            <textarea class="accession-list" id="accessionList" readonly></textarea>
            <button class="copy-button" onclick="copyAccessions()">Copy Accession Numbers</button>
        </div>

        <!-- Step 3: Upload GenBank file and local files -->
        <div class="workflow-section" id="step3" style="display: none;">
            <h2><span class="step-number">3</span>Upload GenBank Data</h2>
            
            <h3>GenBank File (.gb format from NCBI)</h3>
            <div class="file-drop-zone" id="genbankDropZone">
                <p>Drag and drop the .gb file from GenBank here</p>
                <button class="file-button" onclick="document.getElementById('genbankInput').click()">Choose GenBank File</button>
                <input type="file" id="genbankInput" class="file-input" accept=".gb,.genbank,.txt" />
            </div>

            <h3>Local GenBank Files (Optional)</h3>
            <p>Upload any unpublished GenBank flatfiles (.txt format) for local sequences:</p>
            <div class="file-drop-zone" id="localDropZone">
                <p>Drag and drop local GenBank files here (optional)</p>
                <button class="file-button" onclick="document.getElementById('localInput').click()">Choose Local Files</button>
                <input type="file" id="localInput" class="file-input" accept=".txt,.gb,.genbank" multiple />
            </div>

            <div id="uploadStatus"></div>
        </div>

        <!-- Step 4: Process and download -->
        <div class="workflow-section" id="step4" style="display: none;">
            <h2><span class="step-number">4</span>Generate Metadata Spreadsheet</h2>
            <button class="process-button" id="processButton" onclick="processFiles()">Generate Metadata Spreadsheet</button>
            <div class="progress-bar hidden" id="progressBar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div id="processStatus"></div>
            <div id="downloadSection" class="hidden">
                <h3>Download Results:</h3>
                <div id="downloadLinks"></div>
            </div>
        </div>
    </div>

    <script>
        let fastaFile = null;
        let genbankFile = null;
        let localFiles = [];
        let fastaSequences = [];
        let genbankAccessions = [];

        // File upload handlers
        document.getElementById('fastaInput').addEventListener('change', handleFastaUpload);
        document.getElementById('genbankInput').addEventListener('change', handleGenbankUpload);
        document.getElementById('localInput').addEventListener('change', handleLocalUpload);

        // Drag and drop handlers
        setupDropZone('fastaDropZone', 'fastaInput');
        setupDropZone('genbankDropZone', 'genbankInput');
        setupDropZone('localDropZone', 'localInput');

        function setupDropZone(dropZoneId, inputId) {
            const dropZone = document.getElementById(dropZoneId);
            const input = document.getElementById(inputId);

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    if (inputId === 'localInput') {
                        input.files = files;
                        handleLocalUpload({ target: { files: files } });
                    } else {
                        // Create a new FileList with just the first file
                        const dt = new DataTransfer();
                        dt.items.add(files[0]);
                        input.files = dt.files;
                        
                        if (inputId === 'fastaInput') {
                            handleFastaUpload({ target: { files: dt.files } });
                        } else if (inputId === 'genbankInput') {
                            handleGenbankUpload({ target: { files: dt.files } });
                        }
                    }
                }
            });
        }

        function handleFastaUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            fastaFile = file;
            const status = document.getElementById('fastaStatus');
            status.innerHTML = `<div class="status info">Processing FASTA file: ${file.name}</div>`;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseFastaFile(content, file.name);
            };
            reader.readAsText(file);
        }

        function handleGenbankUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            genbankFile = file;
            updateUploadStatus();
            checkReadyToProcess();
        }

        function handleLocalUpload(event) {
            localFiles = Array.from(event.target.files);
            updateUploadStatus();
            checkReadyToProcess();
        }

        function parseFastaFile(content, filename) {
            fastaSequences = [];
            genbankAccessions = [];
            
            const lines = content.split('\n');
            
            for (let line of lines) {
                line = line.trim();
                if (line.startsWith('>')) {
                    const seqId = line.substring(1).split(' ')[0].trim();
                    fastaSequences.push(seqId);
                    
                    // Check if it looks like a GenBank accession
                    if (/^[A-Z]+\d+(\.\d+)?$/i.test(seqId)) {
                        genbankAccessions.push(seqId);
                    }
                }
            }

            const status = document.getElementById('fastaStatus');
            status.innerHTML = `
                <div class="status success">
                    FASTA file processed successfully!<br>
                    Found ${fastaSequences.length} sequences, ${genbankAccessions.length} GenBank accessions
                </div>
            `;

            // Show step 2
            document.getElementById('step2').style.display = 'block';
            
            if (genbankAccessions.length > 0) {
                document.getElementById('accessionList').textContent = genbankAccessions.join('\n');
                document.getElementById('step3').style.display = 'block';
            } else {
                // No GenBank accessions found, skip to local processing
                document.getElementById('step2').innerHTML = `
                    <h2><span class="step-number">2</span>No GenBank Accessions Found</h2>
                    <div class="status info">
                        No GenBank accession numbers were found in your FASTA file. 
                        You can still process local sequences by uploading local GenBank files in Step 3.
                    </div>
                `;
                document.getElementById('step3').style.display = 'block';
                checkReadyToProcess();
            }
        }

        function copyAccessions() {
            const textarea = document.getElementById('accessionList');
            textarea.select();
            document.execCommand('copy');
            
            const button = event.target;
            const originalText = button.textContent;
            button.textContent = 'Copied!';
            button.style.background = '#28a745';
            
            setTimeout(() => {
                button.textContent = originalText;
                button.style.background = '#28a745';
            }, 2000);
        }

        function updateUploadStatus() {
            const status = document.getElementById('uploadStatus');
            let statusHtml = '';

            if (genbankFile) {
                statusHtml += `<div class="status success">GenBank file: ${genbankFile.name}</div>`;
            }

            if (localFiles.length > 0) {
                statusHtml += `<div class="status success">Local files: ${localFiles.map(f => f.name).join(', ')}</div>`;
            }

            status.innerHTML = statusHtml;
        }

        function checkReadyToProcess() {
            const hasData = genbankFile || localFiles.length > 0;
            if (hasData && fastaSequences.length > 0) {
                document.getElementById('step4').style.display = 'block';
            }
        }

        function processFiles() {
            const button = document.getElementById('processButton');
            const status = document.getElementById('processStatus');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');

            button.disabled = true;
            button.innerHTML = '<span class="loading"></span>Processing...';
            status.innerHTML = '<div class="status info">Processing metadata...</div>';
            progressBar.classList.remove('hidden');

            // Simulate progress
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += 10;
                progressFill.style.width = progress + '%';
                if (progress >= 90) {
                    clearInterval(progressInterval);
                }
            }, 200);

            Promise.all([
                genbankFile ? parseGenbankFile(genbankFile) : Promise.resolve({}),
                Promise.all(localFiles.map(file => parseGenbankFile(file)))
            ]).then(([genbankRecords, localRecordsArrays]) => {
                clearInterval(progressInterval);
                progressFill.style.width = '100%';

                // Combine all local records
                const localRecords = {};
                localRecordsArrays.forEach(records => {
                    Object.assign(localRecords, records);
                });

                const allRecords = { ...genbankRecords, ...localRecords };
                const metadata = extractMetadata(fastaSequences, allRecords);
                
                generateSpreadsheet(metadata);
                
                button.disabled = false;
                button.textContent = 'Generate Metadata Spreadsheet';
                status.innerHTML = '<div class="status success">Metadata extraction completed successfully!</div>';
                
                setTimeout(() => {
                    progressBar.classList.add('hidden');
                }, 1000);
            }).catch(error => {
                clearInterval(progressInterval);
                button.disabled = false;
                button.textContent = 'Generate Metadata Spreadsheet';
                status.innerHTML = `<div class="status error">Error: ${error.message}</div>`;
                progressBar.classList.add('hidden');
            });
        }

        function parseGenbankFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const content = e.target.result;
                        const records = parseGenbankContent(content);
                        resolve(records);
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = () => reject(new Error('Failed to read file'));
                reader.readAsText(file);
            });
        }

        function parseGenbankContent(content) {
            const records = {};
            const entries = content.split('//\n');

            for (let entry of entries) {
                if (entry.trim().length === 0) continue;

                try {
                    const record = parseGenbankEntry(entry);
                    if (record && record.accession) {
                        // Store by accession
                        records[record.accession] = record;
                        records[record.accession.split('.')[0]] = record;
                        
                        // Store by specimen voucher if available
                        if (record.specimen_voucher) {
                            records[record.specimen_voucher] = record;
                            // Clean versions for matching
                            const clean = record.specimen_voucher.replace(/[\s\-]/g, '');
                            records[clean] = record;
                        }
                    }
                } catch (error) {
                    console.warn('Error parsing GenBank entry:', error);
                }
            }

            return records;
        }

        function parseGenbankEntry(entry) {
            const lines = entry.split('\n');
            const record = {
                accession: '',
                organism: '',
                specimen_voucher: '',
                geo_loc_name: '',
                collection_date: '',
                collected_by: '',
                isolation_source: '',
                type_material: '',
                references: [],
                features: []
            };

            let currentSection = '';
            let currentFeature = null;

            for (let line of lines) {
                // Handle ACCESSION line
                if (line.startsWith('ACCESSION')) {
                    record.accession = line.substring(10).trim().split(' ')[0];
                }
                
                // Handle SOURCE/ORGANISM
                else if (line.startsWith('  ORGANISM')) {
                    record.organism = line.substring(10).trim();
                }
                
                // Handle FEATURES section
                else if (line.startsWith('FEATURES')) {
                    currentSection = 'features';
                }
                
                // Handle feature lines
                else if (currentSection === 'features' && line.match(/^\s{5}(\w+)\s+/)) {
                    const match = line.match(/^\s{5}(\w+)\s+(.+)/);
                    currentFeature = {
                        type: match[1],
                        location: match[2],
                        qualifiers: {}
                    };
                    record.features.push(currentFeature);
                }
                
                // Handle qualifier lines
                else if (currentSection === 'features' && currentFeature && line.match(/^\s{21}\/(\w+)=/)) {
                    const match = line.match(/^\s{21}\/(\w+)=(.+)/);
                    const qualifier = match[1];
                    let value = match[2];
                    
                    // Remove quotes
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.slice(1, -1);
                    }
                    
                    currentFeature.qualifiers[qualifier] = value;
                    
                    // Store important qualifiers at record level
                    if (qualifier === 'specimen_voucher') record.specimen_voucher = value;
                    else if (qualifier === 'geo_loc_name') record.geo_loc_name = value;
                    else if (qualifier === 'collection_date') record.collection_date = value;
                    else if (qualifier === 'collected_by') record.collected_by = value;
                    else if (qualifier === 'isolation_source') record.isolation_source = value;
                    else if (qualifier === 'type_material') record.type_material = value;
                }
                
                // Handle REFERENCE section
                else if (line.startsWith('REFERENCE')) {
                    currentSection = 'reference';
                    record.references.push({
                        authors: '',
                        title: '',
                        journal: '',
                        year: ''
                    });
                }
                else if (currentSection === 'reference' && line.startsWith('  AUTHORS')) {
                    const ref = record.references[record.references.length - 1];
                    ref.authors = line.substring(10).trim();
                }
                else if (currentSection === 'reference' && line.startsWith('  TITLE')) {
                    const ref = record.references[record.references.length - 1];
                    ref.title = line.substring(8).trim();
                }
                else if (currentSection === 'reference' && line.startsWith('  JOURNAL')) {
                    const ref = record.references[record.references.length - 1];
                    ref.journal = line.substring(10).trim();
                    
                    // Extract year from journal
                    const yearMatch = ref.journal.match(/\((\d{4})\)/);
                    if (yearMatch) {
                        ref.year = yearMatch[1];
                    }
                }
            }

            return record;
        }

        function extractMetadata(sequences, records) {
            const metadata = [];

            for (let seqId of sequences) {
                const entry = createMetadataEntry(seqId, records);
                metadata.push(entry);
            }

            return metadata;
        }

        function createMetadataEntry(seqId, records) {
            // Try to find record by various matching strategies
            let record = findRecord(seqId, records);
            
            const entry = {
                'Fasta ID': seqId,
                'Species Name': 'Unknown',
                'Species Name Genbank': 'Unknown',
                'Collection/Fungarium Number': '',
                'Type status': '',
                'GenBank Accession': '',
                'Location': '',
                'Location simplified': '',
                'Isolation Source': '',
                'Collection Date': '',
                'Collected By': '',
                'iNat/MO Number': '',
                'Notes': '',
                'Reference': '',
                'Bibliography': ''
            };

            if (record) {
                // Extract species name
                if (record.organism) {
                    const parts = record.organism.split(' ');
                    if (parts.length >= 2) {
                        entry['Species Name'] = `${parts[0]} ${parts[1]}`;
                        entry['Species Name Genbank'] = entry['Species Name'];
                    } else {
                        entry['Species Name'] = record.organism;
                        entry['Species Name Genbank'] = record.organism;
                    }
                }

                // Basic fields
                entry['GenBank Accession'] = record.accession || 'Unpublished';
                entry['Collection/Fungarium Number'] = record.specimen_voucher || '';
                entry['Location'] = record.geo_loc_name || '';
                entry['Collection Date'] = record.collection_date || '';
                entry['Collected By'] = record.collected_by || '';
                entry['Isolation Source'] = record.isolation_source || '';

                // Process location for simplified version
                if (entry['Location']) {
                    const parts = entry['Location'].split(':');
                    if (parts.length >= 2) {
                        const country = parts[0].trim();
                        const region = parts[1].trim();
                        
                        if (['USA', 'Canada'].includes(country) && region) {
                            const state = region.split(',')[0].trim();
                            entry['Location simplified'] = `${country}: ${state}`;
                        } else {
                            bibParts.push(`${authors[0]} et al.`);
                        }
                    }
                    
                    if (ref.year) {
                        bibParts.push(`(${ref.year})`);
                    }
                    
                    if (ref.title) {
                        bibParts.push(`${ref.title}.`);
                    }
                    
                    if (ref.journal) {
                        if (ref.journal.toLowerCase().includes('unpublished')) {
                            bibParts.push('Unpublished.');
                        } else if (ref.journal.toLowerCase().includes('submitted')) {
                            bibParts.push('Direct Submission.');
                        } else {
                            bibParts.push(`${ref.journal}.`);
                        }
                    }
                    
                    entry['Bibliography'] = bibParts.join(' ');
                    
                    // Create reference
                    if (ref.authors && ref.year) {
                        const firstAuthor = ref.authors.split(',')[0];
                        entry['Reference'] = `${firstAuthor} ${ref.year}`;
                    } else {
                        entry['Reference'] = entry['Bibliography'].split('.')[0];
                    }
                } else {
                    entry['Reference'] = 'Unpublished';
                    entry['Bibliography'] = 'Unpublished';
                }
            } else {
                // No GenBank record found - try to parse local sequence
                entry = parseLocalSequence(seqId);
            }

            return entry;
        }

        function findRecord(seqId, records) {
            // Try exact match
            if (records[seqId]) return records[seqId];
            
            // Try without version
            const baseAccession = seqId.split('.')[0];
            if (records[baseAccession]) return records[baseAccession];
            
            // Try with cleaned voucher variations
            const cleanId = seqId.replace(/[\s\-_]/g, '');
            if (records[cleanId]) return records[cleanId];
            
            // Try partial matching for voucher numbers
            for (let key in records) {
                if (seqId.includes(key) || key.includes(seqId)) {
                    return records[key];
                }
            }
            
            return null;
        }

        function parseLocalSequence(seqId) {
            const entry = {
                'Fasta ID': seqId,
                'Species Name': 'Unknown',
                'Species Name Genbank': 'Unknown',
                'Collection/Fungarium Number': '',
                'Type status': '',
                'GenBank Accession': 'Unpublished',
                'Location': '',
                'Location simplified': '',
                'Isolation Source': '',
                'Collection Date': '',
                'Collected By': '',
                'iNat/MO Number': '',
                'Notes': '',
                'Reference': 'Unpublished',
                'Bibliography': 'Unpublished'
            };

            // Check for type status
            const typeStatuses = ['HOLOTYPE', 'ISOTYPE', 'PARATYPE', 'NEOTYPE', 'LECTOTYPE', 'SYNTYPE', 'TYPE', 'EPITYPE'];
            for (let status of typeStatuses) {
                if (seqId.toUpperCase().includes(status)) {
                    entry['Type status'] = status.charAt(0).toUpperCase() + status.slice(1).toLowerCase();
                    break;
                }
            }

            // Pattern matching for species names
            let match = seqId.match(/^([A-Z]\.)_([a-z]+)_(.+)/);
            if (match) {
                entry['Species Name'] = `Gymnopilus ${match[2]}`;
                entry['Species Name Genbank'] = entry['Species Name'];
                entry['Collection/Fungarium Number'] = match[3].replace(/_/g, ' ');
            } else if (seqId.startsWith('NR_')) {
                const speciesMatch = seqId.match(/Gymnopilus_([a-z]+)/);
                if (speciesMatch) {
                    entry['Species Name'] = `Gymnopilus ${speciesMatch[1]}`;
                    entry['Species Name Genbank'] = entry['Species Name'];
                }
                if (seqId.includes('TYPE')) {
                    entry['Notes'] = 'From TYPE material';
                }
            } else if (seqId.match(/^G_([a-z]+)/)) {
                const speciesMatch = seqId.match(/^G_([a-z]+)(.+)?/);
                if (speciesMatch) {
                    entry['Species Name'] = `Gymnopilus ${speciesMatch[1]}`;
                    entry['Species Name Genbank'] = entry['Species Name'];
                    if (speciesMatch[2]) {
                        entry['Collection/Fungarium Number'] = speciesMatch[2];
                        if (speciesMatch[2].match(/NYBG\d+/)) {
                            entry['Notes'] = 'NYBG herbarium specimen';
                        }
                    }
                }
            } else if (seqId.match(/^G\.\s+[a-z]+/)) {
                const speciesMatch = seqId.match(/^G\.\s+([a-z]+)/);
                if (speciesMatch) {
                    entry['Species Name'] = `Gymnopilus ${speciesMatch[1]}`;
                    entry['Species Name Genbank'] = entry['Species Name'];
                }
            } else {
                entry['Notes'] = `Could not parse sequence ID: ${seqId}`;
            }

            return entry;
        }

        function generateSpreadsheet(metadata) {
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Convert metadata to worksheet
            const ws = XLSX.utils.json_to_sheet(metadata);
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, "Metadata");
            
            // Generate file
            const filename = `genbank_metadata_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, filename);
            
            // Show download section
            const downloadSection = document.getElementById('downloadSection');
            const downloadLinks = document.getElementById('downloadLinks');
            
            downloadLinks.innerHTML = `
                <div class="file-item">
                    <div>
                        <strong>${filename}</strong><br>
                        <small>Excel spreadsheet with ${metadata.length} entries</small>
                    </div>
                    <button class="download-button" onclick="downloadData('xlsx')">Download XLSX</button>
                </div>
                <div class="file-item">
                    <div>
                        <strong>${filename.replace('.xlsx', '.json')}</strong><br>
                        <small>JSON data for further processing</small>
                    </div>
                    <button class="download-button" onclick="downloadData('json')">Download JSON</button>
                </div>
            `;
            
            downloadSection.classList.remove('hidden');
            
            // Store data for additional downloads
            window.processedMetadata = metadata;
        }

        function downloadData(format) {
            if (!window.processedMetadata) return;
            
            const timestamp = new Date().toISOString().split('T')[0];
            
            if (format === 'xlsx') {
                const wb = XLSX.utils.book_new();
                const ws = XLSX.utils.json_to_sheet(window.processedMetadata);
                XLSX.utils.book_append_sheet(wb, ws, "Metadata");
                XLSX.writeFile(wb, `genbank_metadata_${timestamp}.xlsx`);
            } else if (format === 'json') {
                const jsonData = {
                    metadata: {
                        processing_date: new Date().toISOString(),
                        total_entries: window.processedMetadata.length,
                        fasta_file: fastaFile ? fastaFile.name : 'unknown',
                        genbank_file: genbankFile ? genbankFile.name : 'none',
                        local_files: localFiles.map(f => f.name)
                    },
                    entries: window.processedMetadata
                };
                
                const blob = new Blob([JSON.stringify(jsonData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `genbank_metadata_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }
    </script>
</body>
</html>
                            entry['Location simplified'] = country;
                        }
                    } else {
                        entry['Location simplified'] = entry['Location'];
                    }
                }

                // Extract type status
                if (record.type_material) {
                    const typeStatuses = ['holotype', 'paratype', 'isotype', 'neotype', 'lectotype', 'syntype', 'epitype'];
                    for (let status of typeStatuses) {
                        if (record.type_material.toLowerCase().includes(status)) {
                            entry['Type status'] = status.charAt(0).toUpperCase() + status.slice(1);
                            break;
                        }
                    }
                }

                // Extract iNat/MO numbers
                const allText = [record.specimen_voucher, record.isolation_source, entry['Notes']].join(' ');
                const inatMatch = allText.match(/(inat\s*#?|inaturalist\s*#?)\s*(\d+)/i);
                const moMatch = allText.match(/(mo\s*#?|mushroom\s*observer\s*#?)\s*(\d+)/i);
                
                if (inatMatch) {
                    entry['iNat/MO Number'] = `iNaturalist #${inatMatch[2]}`;
                } else if (moMatch) {
                    entry['iNat/MO Number'] = `Mushroom Observer #${moMatch[2]}`;
                }

                // Create bibliography
                if (record.references && record.references.length > 0) {
                    const ref = record.references[0];
                    const bibParts = [];
                    
                    if (ref.authors) {
                        const authors = ref.authors.split(', ');
                        if (authors.length === 1) {
                            bibParts.push(authors[0]);
                        } else if (authors.length === 2) {
                            bibParts.push(`${authors[0]} & ${authors[1]}`);
                        } else {
